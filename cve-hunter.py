import argparse
import requests
import json
import os

PYTHON_VERSION_DELIMITER = "=="
NPM_VERSION_DELIMITER = ":"

PYTHON_DEPENDENCY_FILENAME = "requirements.txt"
NPM_DEPENDENCY_FILENAME = "package.json"

url = "https://api.osv.dev/v1/query"
# This function parses the python requirements.txt file, takes care of most corner cases
# It parses it into a dict of ('name': 'version) and returns it
def parsePythonDependencies(path):
    dependencies = {}
    try:
        with open(path, "r") as f:
            for line in f:
                # Ignore comments, blank lines and version start/finish (we only want the spec version)
                if line.startswith("#") or line.strip() == "" or line.startswith("  ") and not line.__contains__(PYTHON_VERSION_DELIMITER):
                    continue
                package, version = line.strip().split("==")
                dependencies[package] = version

    except FileNotFoundError:
        print(f"Error: File not found at {path}")
        exit()
    if(not dependencies):
        print("requirements file is empty or unreadable")
        exit()
    
    return dependencies

# This function parses the json package file to a dictionary of ('name': 'version')
# and returns it
def parse_package_json(file_path):
    try:
        with open(file_path) as f:
            data = json.load(f)
    except FileNotFoundError:
        print(f"Error: File not found at {file_path}")
        exit()
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON in file {file_path}")
        exit()
    dependencies = data.get("dependencies", {})
    if not isinstance(dependencies, dict):
        print(f"Error: Dependencies are not a dictionary in file {file_path}")
        exit()
    return dependencies

# This monstrosity of a function recieves a single json-formatted vulnerability report   
# It parses it, and returns the cve and fixed version
def parse_json(vuln):
    cve = vuln['aliases'][0]
    for affected in vuln['affected']:
        for ranges in affected['ranges']:
            for events in ranges['events']:
                if 'fixed' in events:
                    fix = events['fixed']
    return (cve, fix)


# This function uses the argparse package to the given arguments
# it checks if the flags inputted are correct and saves them
def parse_args():
    parser = argparse.ArgumentParser(description='Dependencies CVE finder')
    parser.add_argument('file_path', type=str, help='path to requirements.txt or package.json file')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-r', action='store_true', help='parse requirements.txt file')
    group.add_argument('-p', action='store_true', help='parse package.json file')
    args = parser.parse_args()
    return args


# This function handles the arguments inputted when calling the program, it does the following
# - checks if the inputted file fits the -r or -p flag given, if it does, it sets the fitting environment, else - it exists the program
def handle_args():
    args = parse_args()
    # python
    if args.r:
        if(not args.file_path.endswith(PYTHON_DEPENDENCY_FILENAME)):
            print("Invalid python requirements file (should be called requirements.txt))")
            exit()
        dependencies = parsePythonDependencies(args.file_path)
        environment = "PyPI"
    # npm
    elif args.p:
        if(not args.file_path.endswith(NPM_DEPENDENCY_FILENAME)):
            print("Invalid npm package file (should be called package.json)")
            exit()
        dependencies = parse_package_json(args.file_path)
        environment = "npm"
    return (dependencies, environment)

# This function takes the package name, its version and environment
# and sends it to the OSV API using a post request
# then it parses the json response and retrieves the package cve and fixed version
# aaaaaand then it prints it all
def check_cves(package, version, environment):
    payload = {
    "version": version,
    "package": {
        "name": package,
        "ecosystem": environment
        }
    }
    headers = {
        "Content-Type": "application/json"
    }
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code != 200:
        print("Error: Failed to retrieve data")
        return

    data = response.json()
    if "vulns" not in data:
        return

    for vuln in data['vulns']:
        cve, fix = parse_json(vuln)
    
    print(f"{package.ljust(15)} | {version.ljust(26)} | {cve.ljust(14)} | {fix}")

def print_headers():
    print("\nDependency Name | Current Dependency Version |     CVE ID     | Fix version")
    print("===========================================================================")

 
def main():
    dependencies, environment = handle_args()
    print_headers()
    for package, version in dependencies.items():
        check_cves(package.lower(), version, environment)

if __name__ == '__main__':
    main()

